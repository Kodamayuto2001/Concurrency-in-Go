# Goにおける並行処理の構成要素

- ゴルーチン（goroutine）
    すべてのGoのプログラムには最低1つのゴルーチンがある。
    メインゴルーチン
    これは、プロセスが開始する際に自動的に生成され起動される。
    単純に言えば、ゴルーチンは他のコードに対し並行に実行している関数のこと（注意：必ずしも並列ではない）
    ゴルーチンはgoキーワードを関数呼び出しの前に置くことで簡単に起動できる。
    無名関数でも動作する。（goキーワードを使うには無名関数を即値で呼び出さなければいけない）

    ゴルーチンは（他の言語にも似た並行処理のプリミティブは存在するが）Go特有のもの。
    ゴルーチンはOSスレッドではなく、また必ずしもグリーンスレッド（言語のランタイムにより管理されるスレッド）ではない。
    ゴルーチンはコルーチン（coroutine）として知られる高水準の抽象化。
    コルーチンは単に「プリエンプティブでない」並行処理のサブルーチン（Goでは関数、クロージャー、メソッドに相応）
    つまり割り込みをされることがないということ
    代わりに、コールチンには一時停止や再エントリーを許す複数のポイントがある。

    ```
        プリエンプティブとノンプリエンプティブは、ともにマルチタスクOS上で実行されるプログラムを切り替えるときの方式
        プリエンプティブ
            OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。
        ノンプリエンプティブ
            実行したプロセスの切り替えをプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間で他のタスクを実行する。
            OSがCPUを管理しないので、1つのプログラムを実行中は、他のプログラムの実行は制限される。
    ```

    ゴルーチンが独特なのは、ゴルーチンがGoのランタイムと密結合していること
    ゴルーチンは、一時停止や再エントリーのポイントを定義していない。
    Goのランタイムはゴルーチンの実行時のふるまいを観察し、ゴルーチンがブロックしたら自動的に一時停止し、ブロックが解放されたら再開する。
    これによってある意味ゴルーチンをプリエンプティブにしているが、ゴルーチンがブロックしたときにしか割り込まない。
    このようにランタイムとゴルーチンのロジックには美しい関係性がある。
    以上のことからゴルーチンは特殊なコールチンと考えられる。
    
    コルーチン、また結果としてゴルーチンは、暗黙的には並行処理の構成要素ですが、並行性というのはコールチンの性質ではない。
    並行である場合には、何かが複数のコルーチンが同時管理して、それぞれに実行の機会を与えなければならない。さもなければ、コルーチンが並行になることはない。
    コールチンが暗黙的に並列であるということを示唆するわけではない。
    複数のコルーチンが逐次実行をして（CPUのコア数以上に）並行処理をしているように見せることは確実に可能。
    そしてGoでは常にそれが起こっている。

    Goがゴルーチンをホストする機構は、いわゆるM:Nスケジューラーを呼ばれる実装になっている。
    これはM個のグリーンスレッドをN個のOSスレッドに対応させるもの。
    ゴルーチンはグリーンスレッドにスケジュールされる。
    グリーンスレッドの数よりも多い数のゴルーチンがある場合には、スケジューラーはゴルーチンを利用可能なグリーンスレッドに割り振って、これらのゴルーチンがブロックした場合には他のゴルーチンを実行するようにしている。

    Goはfork-joinモデルを呼ばれる並行処理のモデルに従っている。
    分岐（fork）という用語は、プログラムの任意の場所で、プログラムが子の処理を分岐させて、親と平行に実行させることを指している。
    合流（join）という用語は、分岐した時点から先でこれらの並行処理の分岐が再び合流することを指す。

    ```
        sayHello := func() {
            fmt.Println("hello")
        }

        go sayHello()
    ```

    sayHello関数は自身のゴルーチン上で実行される。かたや、プログラムの続きの部分は引き続き実行される。
    この例には、合流ポイントがない。
    sayHelloを実行しているゴルーチンは単純に将来の不確定なタイミングで終了する。
    プログラムの残りの部分はすでに引き続き実行されている。
    しかしながら、この例には1つ問題がある。
    sayHello関数が実行されたかどうかは不確定。
    ゴルーチンは生成されて、Goのランタイムにスケジュールされるが、もしかするとメインゴルーチンが終了するまでに実行する機会を得られないかもしれない。
    事実、（サンプルを）簡単にするためmain関数の残りの部分を省略したので、この小さなサンプルを実行すると、プログラムがsayHelloの呼び出しをホストしているゴルーチンが起動する前に終了してしまうことがほぼ確実
    ゴルーチンを作った後にtime.Sleepを書くこともできるが、合流ポイントは作成せず、ただ競合状態を作っているだけ。
    プログラムの終了の前にゴルーチンが起動する確率を上げることはできるが、それを保証するものではない。
    合流ポイントはプログラムの正当性を保証し競合状態を取り除くものである。

    合流ポイントを作成するために、メインゴルーチンとsayHelloのゴルーチンを同期しなければならない。
    これはいくつもの方法で実現可能、sync.WaitGroupを使って実装することができる。
    ```
        var wg sync.WaitGroup
        sayHello := func() {
            defer wg.Done()
            fmt.Println("hello")
        }
        wg.Add(1)
        go sayHello()
        wg.Wait()
    ```
    
    この例は決定的にsayHello関数をホストしているゴルーチンが終了するまで、メインゴルーチンをブロックする。
    手早くゴルーチンを生成するためにたくさんの無名関数を使ってきた。
    クロージャは無名関数が作成されたときレキシカルスコープを閉じ込めて、そこに変数を取り込む。
    ゴルーチンの中でクロージャを実行すると、クロージャーはこれらの変数のコピーに対して操作するのか
    それとも元の変数の参照に対してだろうか
    ```
        var wg sync.WaitGroup
        salutation := "hello"
        wg.Add(1)
        go func() {
            defer wg.Done()
            salutation = "welcome"
        } ()
        wg.Wait()
        fmt.Println(salutation)
    ```
    出力は、「welcome」
    ゴルーチンはそれが作られたアドレス空間と同じ空間で実行されることが分かった。
    そしてそれゆえにプログラムが"welcome"を表示している。

    - スコープ
        スコープとは、プログラム中で変数名などのシンボルが参照可能な有効範囲のこと。
        ```
            var hoge = "ほげ";      //  グローバルスコープ（グローバル変数）

            function a() {
                var x = 10;         //  ローカル変数
                console.log(x);
                console.log(hoge);
            }

            function b() {
                var hoge = "hoge";  //  ローカル変数
                console.log(hoge);
            }

            console.log(hoge);      //  ほげ
            console.log(x);         //  error
        ```
    - レキシカルスコープ
        ローカル変数の有効範囲は関数の定義時に決まるものなのか、他の場所で呼び出した時に決まるのか？
        レキシカルスコープは関数を定義した時点でスコープが決まる。
        ```
            var x = 10;
            function A() {
                console.log(x);         //  x = 10
            }

            function B() {
                var x = 1000;           //  ここでも定義されている。
                A();                    //  x = ?
            }

            A()                         //  10
            B()                         //  10
        ```

    - ダイナミックスコープ
        ```
            var x = 10;
            function A() {
                console.log(x);         //  x = 10
            }

            function B() {
                var x = 1000;           //  ここでも定義されている。
                A();                    //  x = ?
            }

            A()                         //  10
            B()                         //  1000（10ではなくなった）
        ```

    - クロージャ
        クロージャは「関数」と「その関数が作られた環境」という2つのものが一体となった特殊なオブジェクト
        この「環境」というのは、クロージャが作られた時点でスコープ内部にあったあらゆる変数や関数・オブジェクトなどによって構成される。
    
        ```
        function fnA() {
            var hoge = "ほげ";
            console.log(hoge);

            function fnB() {
                alert(hoge);
            }

            return fnB;
        }

        var myFunc = fnA();

        myFunc();
        //  myFunc();
        ```

        実行結果
            1. コンソールに"ほげ"という出力がされる
            2. アラートで"ほげ"とメッセージが出現する

        もう一度myFunc();を呼び出してあげると、コンソールの出力はなく、アラートで"ほげ"とでてくるのみ
        ローカル変数hogeは、関数fnA内部のローカル変数であるので、関数fnAの実行中以外では参照することはできないはずです。
        「JavaScriptのローカル変数は、関数が実行されるたびに作成され破棄される」「関数内部のローカル変数は、その関数が実行されている間だけ存在する」

        では、上記の例で関数fnAを実行しているのはどこかというと、変数myFuncが定義されたとき
        つまり、この瞬間でのみ、ローカル変数hogeを参照することができる。
        関数fnAの中身を見ると「return fnB;」とあるので、グローバル変数myFuncに代入されるのは、関数fnBということになる。
        
        「var myFunc = fnA();」の部分を置き換えてみると
        ```
        var myFunc = function fnB() {
            alert(hoge);
        }
        ```

        つまり、「myFunc()」=「alert(hoge);」となる。

        関数fnAが実行されていないのに、関数fnA内部のローカル変数hogeを参照できている
        「クロージャは「関数」と「その関数が作られた環境」という2つのものが一体となった特殊なオブジェクト」

        関数がクロージャになる条件
        「関数は定義時のコンテキストとは異なるコンテキスト上に持ち出されるとクロージャになる」

        関数fnAのような親関数の実行によって、ローカル関数が外部へと持ち出されるときにクロージャが生成されることが分かった。
        このような、クロージャを生成できる親関数のことを「エンクロージャー」と呼ぶらしい


    ```
        var wg sync.WaitGroup
        for _, salutation := range []string{"hello", "greetings", "good day"} {
            wg.Add(1)
            go func() {
                defer wg.Done()
                fmt.Println(salutation) //  1
            }()
        }
        wg.Wait()
    ```

    1. ここで文字列スライスをrangeしたときに作られたループ変数のsalutationを参照している。

    結果
    ```
        good day
        good day
        good day
    ```

    この例では、ゴルーチンは文字列型の反復変数salutationを囲むクロージャーを実行している。
    ループが繰り返すごとにsalutationには次のスライスリテラル内の文字列値が代入される。
    ゴルーチンは未来の任意のタイミングにスケジュールされているので、ゴルーチンの中で土の値が表示されるかは不確定。
    ゴルーチンが開始する前にループが終了してしまうことがほとんど
    つまり、salutation変数はスコープ買いになってしまう。
    ゴルーチンはスコープ買いのものを参照し続けることができるのだろうか
    ガベージコレクションされる可能性があるメモリをアクセスして今うのか

    これはGoのメモリ管理に関する面白いこぼれ話
    Goのランタイムは気が利いているので変数salutationへの参照がまだ保持されているかを知っていて、ゴルーチンがそのメモリにアクセスし続けられるようにメモリをヒープに移す。
    通常のマシンでは、どんなゴルーチンでも開始する前にループが終了してしまう。なのでsalutationは文字列のスライスの最後の値であるgood dayへの参照を保持したままヒープに移される。
    それゆえ、私のマシンでは通常good dayが3回表示される。
    個のループを想定したように正しく書くには、salutationのコピーをクロージャーに渡して、ゴルーチンが実行されるようになるまでにループの各繰り返しから渡されたデータを操作できるようにする。
    ```
        var wg sync.WaitGroup
        for _, salutation := range []string{"hello", "greetings", "good day"} {
            wg.Add(1)
            go func(salutation string) {    //  1
                defer wg.Done()
                fmt.Println(salutation)
            }(salutation)                   //  2
        }
        wg.Wait()
    ```

    1. ここで、普通の関数と同じように引数を宣言する。元のsalutation変数をシャドーイングして何を渡すべきかを明確にする。
    2. ここで現在の繰り返しの変数をクロージャーに渡す。文字列の構造体のコピーが行われ、それによってゴルーチンが実行されたときに、適切な文字列を参照するようにする。

    結果
    ```
        good day
        hello
        greetings
    ```
    このれいは想定したとおりに動作している。
    そしてわずかながらより詳細に記述されている。
    ゴルーチンはお互いに同じアドレス空間を操作していて、単純に関数をホストしているため、ゴルーチンを使うことは並行でないコードを書くことの自然な延長になっている。
    Goのコンパイラはうまい具合に変数をメモリに割り当ててくれて、ゴルーチンが解放されたメモリに間違ってアクセスしてしまわないようにしている。これによって開発者がメモリ管理ではなく問題空間に集中できる。
    しかしなんでも勝手にできるわけではない。
    複数のゴルーチンが同じアドレス空間に対して操作するので、依然として同期に関しては気にかけねばならない。先に説明したように、ゴルーチンがアクセスする共有メモリへのアクセスを同期する、またはCSPのプリミティブを使って通信によってメモリを共有するか、いずれかの方法を選択できる。
    ゴルーチンのほかの利点は、ゴルーチンが信じられないほど軽量であること。
    新しく生成されたゴルーチンには数キロバイトのメモリが与えられる。これでほぼ問題ない。もしメモリが足りない場合は、ランタイムがメモリを自動的に増加（あるいは現象）させてスタックを保持できるようにし、多くのゴルーチンが適切な量のメモリの中で生存できるようにしている。CPUのオーバーヘッドとして関数呼び出しごとに平均でコストが低い操作を3つ程度行う。実際に、何百男全ものゴルーチンが同じアドレス空間に生成されている。ゴルーチンが単位スレッドだったら、もっとずっと少ない数でシステムリソースが枯渇してしまうだろう


    ```
        memConsumed := func() uint64 {
            runtime.GC()
            var s runtime.MemStats
            runtime.ReadMemStats(&s)
            return s.Sys
        }

        var c <-chan interface{}
        var wg sync.WaitGroup
        noop := func() { wg.Done(); <-c }       //  1

        const numGoroutines = 1e4               //  2
        wg.Add(numGoroutines)
        before := memConsumed()                 //  3
        for i := numGoroutines; i > 0; i-- {
            go noop()
        }
        wg.Wait()
        after := memConsumed()                  //  4
        fmt.Printf("%.3fkb\n", float64(after-before)/numGoroutines/1000)
    ```

    1. 計算のためにたくさんのゴルーチンをメモリに置いておきたいので、絶対に終了しないゴルーチンが必要。ただ、個のゴルーチンはプロセスが終わるまで終了しない。
    2. ここで生成するゴルーチンの数を定義している。台数の法則を使って漸近的にゴルーチンの数を増やしていく。
    3. ここでゴルーチン生成前のメモリ消費量を計算する。
    4. ここでゴルーチン生成後のメモリ消費量を計算する。
    
    コンテキストスイッチ
    コンテキストスイッチとは並行プロセスをホストしているものが別の並行プロセスに切り替えるために状態を保存しなければならないときにおこるもの。
    並行プロセスが過剰にある場合、CPU時間をすべてコンテキストスイッチに費やしてしまい、本来行いたい処理が一切行われないということが起こりえる。オペレーティングシステムの層でいえば、スレッドのコンテキストスイッチは非常にコストが高くなる。OSスレッドはレジスタの値、参照テーブル、メモリマップといったものを保存して、今必要なスレッドに切り替えなければならない。そして、そういった情報を新しいスレッドに読み込ませなければならない。
    ソフトウェア内に置けるコンテキストスイッチのコストは、これに比較するとずっとずっと小さくなる。ソフトウェアで定義したスケジューラでは、ランタイムは何をどのように、いつ永続化すべきかに関して、より多くの選択肢がある。

    ```
    func BenchmarkContextSwitch(b *testing.B) {
        var wg sync.WaitGroup
        begin := make(chan struct{})
        c := make(chan struct{})

        var token struct{}
        sender := func() {
            defer wg.Done()
            <-begin         //  1
            for i := 0; i < b.N; i++ {
                c <- token  //  2
            }
        }
        receiver := func() {
            defer wg.Done()
            <-begin         //  1
            for i := 0; i < b.N; i++ {
                <-c         //  3
            }
        }

        wg.Add(2)
        go sender()
        go receiver()
        b.StartTimer()      //  4
        close(begin)        //  5
        wg.Wait()
    }
    ```

    1. 開始(begin)といわれるまで待機する。コンテキストスイッチの計測にゴルーチンの設定と起動の時間を入れたくなかったから。
    2. 受信側のゴルーチンにメッセージを送信している。struct{}はから構造体と呼ばれるもので、メモリを消費しない。これによって、メッセージを創出する時間だけを計測できる。
    3. メッセージを受信するが、何もしない。
    4. タイマーを起動する。
    5. 2つのゴルーチンに開始を伝える。

- syncパッケージ
    syncパッケージには低水準のメモリアクセス同期に便利な並行処理のプリミティブが入っている。
    Goに特有の点といえば、Goではメモリアクセス同期のプリミティブの上に新しい並行処理のプリミティブを作り、新しい道具を用意したところ。
    これらの操作は、たいていはstructのような小さなスコープ
    メモリアクセス同期がいつ適切かを決めるのは利用者次第。
    syncパッケージにあるプリミティブ

- WaitGroup
    WaitGroupはひとまとまりの並行処理があったとき、その結果を気にしない、若しくは他に結果を収集する手段がある場合に、それらの処理の完了を待つ手段として非常に有効。
    どちらの前提も当てはまらない場合には、かわりにselect文を使うことをお勧めする。
    WaitGroupは非常に便利
    ```
        var wg sync.WaitGroup

        wg.Add(1)               //  1
        go func() {
            defer wg.Done()     //  2
            fmt.Println("1st goroutine sleeping...")
            time.Sleep(1)
        }()

        wg.Add(1)               //  1
        go func() {
            defer wg.Done()     //  2
            fmt.Println("2nd goroutine sleeping...")
            time.Sleep(2)
        }()

        wg.Wait()               //  3
        fmt.Println("All goroutines complete.")
    ```

    1. Addを引数に1を渡して呼び出し、1つのゴルーチンが起動したことを表している。
    2. Doneをdeferキーワードを使って呼び出して、ゴルーチンのクロージャが終了する前にWaitGroupに終了することを確実に伝えるようにしている。
    3. Waitを呼び出している。すべてのゴルーチンが終了したと伝えるまでメインゴルーチンをブロックする。

    WaitGroupを並行処理で安全なカウンターと考えることができる。
    Addを呼び出すと引数に渡された整数だけカウンターを増やし、Doneを呼び出すとカウンターを1つ減らす。Waitを呼び出すとカウンターがゼロになるまでブロックする。
    Addの呼び出しは監視対象のゴルーチンの外で行われている。
    こうしないと競合状態を引き起こしてしまう。
    ゴルーチンがスケジュールされるタイミングに関しては何の保証もないから。
    ゴルーチンが開始する前にWaitの呼び出しが起きてしまう可能性がある。ゴルーチンのクロージャの中でAddが呼び出されている場合、Addの呼び出しが実行されないためWaitの呼び出しはブロックせずに実行されてしまうかもしれない。

    Addの呼び出しはできる限り監視対象のゴルーチンの直前に書くというのが慣習。しかし、時に関連するゴルーチンの呼び出しを一度に監視するために、Addの呼び出しが行われているのを見ることもあるだろう。
    ```
        hello := func(wg *sync.WaitGroup, id int) {
            defer wg.Done()
            fmt.Printf("Hello from %v\n", id)
        }

        const numGreeters = 5
        var wg sync.WaitGroup
        wg.Add(numGreeters)
        for i := 0; i < numGreeters; i++ {
            go hello(&wg, i+1)
        }
        wg.Wait()
    ```

    - MutexとRWMutex
        メモリアクセス同期を使って並行処理を扱う言語に慣れている人であれば、Mutexと聞いてすぐにわかるだろう。
        Mutexは「相互排他」を表す英語の mutual exclusionの略で、プログラム内のクリティカルセクションを保護する方法の一つ。クリティカルせくりょんは、プログラムが共有リソースに対する排他的アクセスを必要とする場所のこと。Mutexは並行処理で安全な方法でこれらの共有リソースに対する排他的アクセスを提供している。
        「Goらしさ」の発言を借りてくれば、チャネルは通信によってメモリを共有し、Mutexは開発者が守らなければならないメモリに対する同期アクセスの観衆を作ることでメモリを共有している。ミューテックスを使ってこのメモリに対する慎重なアクセスを自分で調整する責任がある。ここで共通の変数をそれぞれ増加と減少させようとしている2つのゴルーチンの例を見る。この例ではMutexを使って変数へのアクセスを同期している。

        ```
            var count int
            var lock sync.Mutex

            increment := func() {
                lock.Lock()         //  1
                defer lock.Unlock() //  2
                count++
                fmt.Printf("Incrementing: %d\n", count)
            }

            decrement := func() {
                lock.Lock()         //  1
                defer lock.Unlock() //  2
                count--
                fmt.Printf("Decrementing: %d\n", count)
            }

            //  インクリメント
            var arithmetic sync.WaitGroup
            for i := 0; i <= 5; i++ {
                arithmetic.Add(1)   
                go func() {
                    defer arithmetic.Done()
                    increment()
                }()
            }

            //  デクリメント
            for i := 0; i <= 5; i++ {
                arithmetic.Add(1)
                go func() {
                    defer arithmetic.Done()
                    decrement()
                }()
            }

            arithmetic.Wait()

            fmt.Println("Arithmetic complete.")
        ```

        1. lockというMutexインスタンスで保護されたクリティカルセクション（この場合count変数の占有）を要求している。
        2. lockが保護しているクリティカルセクションでの処理が終了したことを示している。

        Unlockへの呼び出しが常にdeferの中にある。
        これはMutexを使うときによく使われるイディオム
        これによって、たとえpanicになったとしても確実に呼び出せる。
        呼び出しに失敗してしまうとデッドロックが発生してしまう。
        クリティカルセクションはプログラムのボトルネックを反映しているので、そう名付けられた
        クリティカルセクションへの出入りはいくらかコストが高いので、一般的にはクリティカルセクションで消費される時間を極力短くしようとする。
        そうするための戦略の1つはクリティカルセクションの断面積を減らすこと。
        複数の並行処理のプロセスで共有する必要があるメモリがあるかもしれない。
        しかし、おそらくそれらのプロセスのうちの全てがメモリの読み込みと書き込みの両方を必要とするわけではない。もしそうであれば、別種類のミューテックスであるsync.RWMutexが使える。
        sync.RWMutexは概念的には、Mutexと同じもの。これもメモリへのアクセスを保護する。しかしながらRWMutexはメモリに対する管理をMutexより多く提供している。
        メモリに対する読み込みのロックを要求した場合、ロックが書き込みで保持されていなければ、アクセスを得ることができる。
        つまり、書き込みのロックをしているものがいなければ、任意の数の読み込みのロックがとれるというわけ。

        ```
            producer := func(wg *sync.WaitGroup, l sync.Locker) {   //  1
                defer wg.Done()
                for i := 5; i > 0; i-- {
                    l.Lock()
                    l.Unlock()
                    time.Sleep(1)   //  2
                }
            }

            observer := func(wg *sync.WaitGroup, l sync.Locker) {
                defer wg.Done()
                l.Lock()
                defer l.Unlock()
            }

            test := func(count int, mutex, rwMutex sync.Locker) time.Duration {
                var wg sync.WaitGroup
                wg.Add(count+1)
                beginTestTime := time.Now()
                go producer(&wg, mutex)
                for i := count; i > 0; i-- {
                    go observer(&wg, rwMutex)
                }

                wg.Wait()
                return time.Since(beginTestTime)
            }

            tw := tabwriter.NewWriter(os.Stdout, 0, 1, 2, ' ', 0)
            defer tw.Flush()

            var m sync.RWMutex
            fmt.Fprintf(tw, "Readers\tRWMutex\tMutex\n")
            for i := 0; i < 20; i++ {
                count := int(math.Pow(2, float64(i)))
                fmt.Fprintf(
                    tw,
                    "%d\t%v\t%v\n",
                    count,
                    test(count, &m, m.RLocker()),
                    test(count, &m, &m),
                )
            }
        ```

        1. producer関数の2番目の引数はsync.Locker型。このインターフェースにはLockとUnlockという2つのメソッドがある。このインターフェースはMutex型とRWMutex型を満たす。
        2. 生産者を1ナノ秒スリープさせて、observerゴルーチンよりも非活発にする。

        論理的に意味があると思うときはMutexではなく、RWMutexを使うことをお勧め
        


# Goにおける並行処理の構成要素

- ゴルーチン（goroutine）
    すべてのGoのプログラムには最低1つのゴルーチンがある。
    メインゴルーチン
    これは、プロセスが開始する際に自動的に生成され起動される。
    単純に言えば、ゴルーチンは他のコードに対し並行に実行している関数のこと（注意：必ずしも並列ではない）
    ゴルーチンはgoキーワードを関数呼び出しの前に置くことで簡単に起動できる。
    無名関数でも動作する。（goキーワードを使うには無名関数を即値で呼び出さなければいけない）

    ゴルーチンは（他の言語にも似た並行処理のプリミティブは存在するが）Go特有のもの。
    ゴルーチンはOSスレッドではなく、また必ずしもグリーンスレッド（言語のランタイムにより管理されるスレッド）ではない。
    ゴルーチンはコルーチン（coroutine）として知られる高水準の抽象化。
    コルーチンは単に「プリエンプティブでない」並行処理のサブルーチン（Goでは関数、クロージャー、メソッドに相応）
    つまり割り込みをされることがないということ
    代わりに、コールチンには一時停止や再エントリーを許す複数のポイントがある。

    ```
        プリエンプティブとノンプリエンプティブは、ともにマルチタスクOS上で実行されるプログラムを切り替えるときの方式
        プリエンプティブ
            OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。
        ノンプリエンプティブ
            実行したプロセスの切り替えをプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間で他のタスクを実行する。
            OSがCPUを管理しないので、1つのプログラムを実行中は、他のプログラムの実行は制限される。
    ```

    ゴルーチンが独特なのは、ゴルーチンがGoのランタイムと密結合していること
    ゴルーチンは、一時停止や再エントリーのポイントを定義していない。
    Goのランタイムはゴルーチンの実行時のふるまいを観察し、ゴルーチンがブロックしたら自動的に一時停止し、ブロックが解放されたら再開する。
    これによってある意味ゴルーチンをプリエンプティブにしているが、ゴルーチンがブロックしたときにしか割り込まない。
    このようにランタイムとゴルーチンのロジックには美しい関係性がある。
    以上のことからゴルーチンは特殊なコールチンと考えられる。
    
    コルーチン、また結果としてゴルーチンは、暗黙的には並行処理の構成要素ですが、並行性というのはコールチンの性質ではない。
    並行である場合には、何かが複数のコルーチンが同時管理して、それぞれに実行の機会を与えなければならない。さもなければ、コルーチンが並行になることはない。
    コールチンが暗黙的に並列であるということを示唆するわけではない。
    複数のコルーチンが逐次実行をして（CPUのコア数以上に）並行処理をしているように見せることは確実に可能。
    そしてGoでは常にそれが起こっている。

    Goがゴルーチンをホストする機構は、いわゆるM:Nスケジューラーを呼ばれる実装になっている。
    これはM個のグリーンスレッドをN個のOSスレッドに対応させるもの。
    ゴルーチンはグリーンスレッドにスケジュールされる。
    グリーンスレッドの数よりも多い数のゴルーチンがある場合には、スケジューラーはゴルーチンを利用可能なグリーンスレッドに割り振って、これらのゴルーチンがブロックした場合には他のゴルーチンを実行するようにしている。

    Goはfork-joinモデルを呼ばれる並行処理のモデルに従っている。
    分岐（fork）という用語は、プログラムの任意の場所で、プログラムが子の処理を分岐させて、親と平行に実行させることを指している。
    合流（join）という用語は、分岐した時点から先でこれらの並行処理の分岐が再び合流することを指す。

    ```
        sayHello := func() {
            fmt.Println("hello")
        }

        go sayHello()
    ```

    sayHello関数は自身のゴルーチン上で実行される。かたや、プログラムの続きの部分は引き続き実行される。
    この例には、合流ポイントがない。
    sayHelloを実行しているゴルーチンは単純に将来の不確定なタイミングで終了する。
    プログラムの残りの部分はすでに引き続き実行されている。
    しかしながら、この例には1つ問題がある。
    sayHello関数が実行されたかどうかは不確定。
    ゴルーチンは生成されて、Goのランタイムにスケジュールされるが、もしかするとメインゴルーチンが終了するまでに実行する機会を得られないかもしれない。
    事実、（サンプルを）簡単にするためmain関数の残りの部分を省略したので、この小さなサンプルを実行すると、プログラムがsayHelloの呼び出しをホストしているゴルーチンが起動する前に終了してしまうことがほぼ確実
    ゴルーチンを作った後にtime.Sleepを書くこともできるが、合流ポイントは作成せず、ただ競合状態を作っているだけ。
    プログラムの終了の前にゴルーチンが起動する確率を上げることはできるが、それを保証するものではない。
    合流ポイントはプログラムの正当性を保証し競合状態を取り除くものである。

    合流ポイントを作成するために、メインゴルーチンとsayHelloのゴルーチンを同期しなければならない。
    これはいくつもの方法で実現可能、sync.WaitGroupを使って実装することができる。
    ```
        var wg sync.WaitGroup
        sayHello := func() {
            defer wg.Done()
            fmt.Println("hello")
        }
        wg.Add(1)
        go sayHello()
        wg.Wait()
    ```
    
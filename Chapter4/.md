# Goでの並行処理パターン

- 拘束
    並行なコードを扱うときに、安全な操作をするためにはいくつかの異なる方法が考えられる。
    これまで見てきたものは以下の通り。
    
    - メモリを共有するための同期のプリミティブ（例：sync.Mutex）
    - 通信による同期（例：チャネル）

    しかしながら、複数の並行プロセス内で暗黙的に安全な方法が他にもいくつかある。

    - イミュータブルなデータ
    - 拘束によって保護されたデータ

    ある意味で、イミュータブルなデータは暗黙的に「並行処理において安全」であり理想的
    各並行プロセスは同じデータに対して操作できるが、変更できない。
    新しいデータを作りたければ、そのデータをコピーしてから必要な変更を行う。
    これによって開発者がデータの中身を認識する負荷を軽減するだけでなく、クリティカルセクションを小さく（あるいはまったく無く）して、より速いプログラムにもなりえる。
    Goではメモリ内の値へのポインターの代わりに値のコピーを使るようなプログラムを書くことで実現できる。
    言語によっては、明示的にイミュータブルな値をもったポインターを扱うことができるが、Goではできない。

    拘束によっても開発者がデータの中身を認識する負荷を下げ、クリティカルセクションを小さくできる。
    並行処理で扱う値を拘束する技術は単純に値のコピーを渡すよりやや複雑になる。

    拘束は、情報をたった1つの並行プロセス空のみ得られることを確実にしてくれる単純だが強力な考え方。
    これが確実に行われたときには、並行プログラムは暗黙的に安全で、また同期が全く必要なくなる。
    拘束は2種類存在している。
    アドホックとレキシカルの2つ。

    アドホック拘束とは、拘束を規約（例えば言語コミュニティ、職場のチーム、あるいは触っているコードベースなどによって指定されている規則）によって達成した場合を指す。
    どのような規模のコミュニティにおいても、誰かがコードをコミットするたびに静的解析を実行してくれるようなツールがない限り、規則を守り続けるのは難しい。
    アドホック拘束の例を以下に示す。

    ```
        data := make([]int, 4)

        loopData := func(handleData chan<- int) {
            defer close(handleData)
            for i := range data {
                handleData <- data[i]
            }
        }

        handleData := make(chan int)
        go loopData(handleData)

        for num := range handleData {
            fmt.Println(num)
        }
    ```

    整数のスライスであるdataがloopData関数でもhandleDataチャネルに対する繰り返しでも利用できることが分かる。
    しかしながら、規約によってloopData関数のみからアクセスしている。
    しかし、コードが多くの人に手を入れられて、締め切りが迫ってくるにつれて、間違ったコードが混入し、拘束が破られて、問題が起きる。
    静的解析ツールはこういった類の問題を捕まえてくれるかもしれない。
    Goのコードベースに対する静的解析の導入は「多くの開発チームがそれを導入できる成熟度に到達できていない」ことを示す。
    レキシカル拘束を好む理由。
    これはコンパイラを駆使して拘束を強制するというもの。

    レキシカル拘束はレキシカルスコープを使って適切なデータと並行処理のプリミティブだけを複数の並行プロセスが使えるように公開することを示している。
    これによって誤った処理を書いてしまうことを不可能にしている。
    チャネルを必要とする並行プロセスにそのチャネルへの読み書きのうち必要な権限だけ公開する。

    ```
        chanOwner := func() <-chan int {
            results := make(chan int, 5)        //  1
            go func() {
                defer close(results)
                for i := 0; i <= 5; i++ {
                    results <- i
                }
            }()
            return results
        }

        consumer := func(results <-chan int) {  //  3
            for result := range results {
                fmt.Printf("Received: %d\n", result)
            }
            fmt.Println("Done receiving!")
        }

        results := chanOwner()                  //  2
        cosumer(results)
    ```

    1. チャネルをchanOwner関数のレキシカルスコープ内で初期化している。これによってresultsチャネルへの書き込みができるスコープを制限している。言い換えれば、このチャネルへの書き込み権限を拘束して、他のゴルーチンの書き込みを防いでいる。
    2. チャネルへの読み込み権限を受け取って、消費者に渡す。消費者は読み込み以外は何もしない。再度になるが、これによりメインゴルーチンにはこのチャネルへの読み込みだけが見えるように拘束する。
    3. intのチャネルの読み込み専用のコピーを受け取る。読み込み権限のみが必要であることを宣言することで、consumer関数内でのこのチャネルに対する操作を読み込み専用に拘束する。

    このように設定することで、この小さな例の中にあるresultチャネルは直接利用できなくなる。
    これは拘束の良い導入ではあるが、チャネルは並行安全なのでおもしろい例ではない。
    並行安全ではないデータ構造を使った高速の例。ここではbytes.Bufferを使う。

    ```
        printData := func(wg *sync.WaitGroup, data []byte) {
            defer wg.Done()

            var buff bytes.Buffer
            for _, b := range data {
                fmt.Fprintf(&buff, "%c", b)
            }
            fmt.Println(buff.String())
        }

        var wg sync.WaitGroup
        wg.Add(2)
        data := []byte("golang")
        go printData(&wg, data[:3])     //  1
        go printData(&wg, data[3:])     //  2
    ```

    1. dataの中の先頭の3バイトを含んだスライスを渡す。
    2. dataの中の後半の3バイトを含んだスライスを渡す。
    
    この例でprintDataはdataスライスの宣言の後にないので直接アクセスできず、引数としてbyteのスライスを渡してもらう必要がある。
    printDataを呼び出すゴルーチンでそれぞれ別の部分集合を渡しているので、起動したゴルーチンがそれぞれdataの一部しかアクセスできないように拘束している。
    レキシカルスコープによって、間違ったアクセスを不可能にした。
    またこうすることでメモリアクセスの動機や通信によるデータの共有を行う必要がなくなる。

    同期を利用できるのに、なぜ高速を使おうとするのか？
    パフォーマンス向上と、開発者に対する可読性の向上が理由。
    同期はコストが高くなり、使用を避けることができればクリティカルセクションを持たずに済む。
    またそれゆえに、同期のコストを書ける必要がなくなる。
    また同期を行うことで発生しうる問題すべてを回避できる。
    つまり開発者は単純にこういった類の問題を全く気にする必要がなくなる。
    さらにレキシカル拘束を利用する並行処理のコードは、そうでないコードに比較して一般的には理解しやすいものになるという利点がある。
    その理由は、レキシカルスコープのコンテキストの中では同期なコードを書けるから。

    拘束をきちんと作るのは難しいこともある。
    そのさいは、Goの並行処理のプリミティブを利用しなければならなくなる。


- for-selectループ
    ```
        for {           //  無限ループまたは何かのイテレーションを回す
            select {
                //  チャネルに対して何かを行う
            }
        }
    ```

    //  このパターンが出現するシナリオはいくつかある。

    - チャネルから繰り返しの変数を送出する。
        しばしば繰り返しが可能なものをチャネル上の変数に変換したいことがある。
        これは全く派手ではない。
        次のような見た目となる。
        ```
            for _, s := range []string{"a", "b", "c"} {
                select {
                case <-done:
                    return
                case stringStream <- s:
                }
            }
        ```

    - 停止シグナルを待つ無限ループ
        外部から停止の命令が来るまで無限に繰り返すゴルーチンを作るのはよくあること。
        パターンにはいくつかの変形がある。
        1つ目の形式はselect文を極力短くするもの。
        ```
            for {
                select {
                case <-done:
                    return
                default:
                }

                //  割り込みできない処理をする
            }
        ```

        doneチャネルが閉じられていなければ、select文を抜けてforループの本体の残りの処理を続ける。
        2つ目の形式ではselect文のdefault節に処理を埋め込む
        ```
            for {
                select {
                case <-done:
                    return
                default:
                    //  割り込みできない処理をする
                }
            }
        ```
        select文に入ったときに、doneチャネルが閉じられていなければ、代わりにdefault節を実行する。
        このパターンに関してはこれ以上のものはない。
        しかし、このパターンはどこでも見かけるので、ここで触れておく価値はあるだろう。

- ゴルーチンリークを避ける
    ゴルーチンの生成はコストが小さく容易。
    これこそが、Goをこれほどまでに生産的な言語たらしめている要素の1つ。
    ランタイムがゴルーチンをいかなる数のOSスレッドにもマルチプレキシングしてくれるので、我々が抽象化の層に関して気にする必要はほとんどない。
    しかし、少ないとはいえゴルーチンもコストがかかり、またゴルーチンはランタイムによってガベージコレクションされない。
    それゆえ、ゴルーチンのメモリフットプリントがどれほど小さいといっても、プロセス内にほったらかしにしてはならない。
    ゴルーチンを確実に片づけたらよいのか？

    なぜゴルーチンは存在するのか？
    ゴルーチンはお互いに並列に動作しているかどうかにかかわらず仕事の単位を表していること。
    ゴルーチンが終了に至るまでの流れはいくつかの種類がある。

    - ゴルーチンが終了を完了する場合
    - 回復できないエラーにより処理を続けられない場合
    - 停止するように命令された場合

    最初の2つの流れに関しては何もしないでも実行される（自分のアルゴリズム次第）
    しかし、キャンセル処理に関してはどうだろうか。
    このことはネットワーク降下より最も重要であると分かった。
    あなたがゴルーチンを起動すれば、それはたいてい何らかの整理されたやり方で他のいくつかのゴルーチンと強調しており、この相互に連結された状態はグラフで書き表せるだろう。
    子のゴルーチンが処理を続けるべきかどうかは他の多くのゴルーチンの状態を知ることが前提となる。
    親のゴルーチン（しばしばメインゴルーチン）がこういったコンテキストをすべて知ることで、子のゴルーチンに終了するよう命令できるようになるだろう。
    簡単なゴルーチンリークの例は以下の通り。
    ```
        doWork := func(strings <-chan string) <-chan interface{} {
            completed := make(chan interface{})
            go func() {
                defer fmt.Println("doWork exited.")
                defer close(completed)
                for s := range strings {
                    //  何か面白い処理
                    fmt.Println(s)
                }
            }()
            return completed
        }

        doWork(nil)
        //  もう少し何かしらの処理がここで行われる
        fmt.Println("Done.")
    ```
    この例では、メインゴルーチンがnilチャネルをdoWorkに渡している。
    それゆえ、stringsチャネルには実際には絶対に文字列が書き込まれることはなく、doWorkを含むゴルーチンはこのプロセスが生きている限りずっとメモリ内に残る。（もしdoWorkないのゴルーチンとメインゴルーチンをつなげていたらデッドロックしていただろう）
    
    このれいではプロセスの生存時間は短いが、実際のプログラムではゴルーチンは長時間稼働するプログラムの初めのほうで簡単に起動される。
    最悪の場合、メインゴルーチンは稼働し続ける限りゴルーチンを生成し続け、メモリ使用率をじわじわと高めていく。

    こうした問題を上手に軽減させるためには、ゴルーチンの親子間で親から子にキャンセルのシグナルを送れるようにする。
    慣習として、このシグナルは通常doneという名前の読み込み専用チャネルにする。
    親ゴルーチンはこのチャネルを子ゴルーチンに渡して、キャンセルさせたいときにチャネルを閉じる。
    その例が次の通り。
    ```
        doWork := func(done <-chan interface{}, strings <-chan strings) <-chan interface{} {        //  1
            terminated := make(chan interface{})
            go func() {
                defer fmt.Println("doWork exited.")
                defer close(terminated)
                for {
                    select {
                    case s := <-strings:
                        //  何か面白い処理
                        fmt.Println(s)
                    case <-done:        //  2
                        return
                    }
                }
            }
            return terminated
        }

        done := make(chan interface{})
        terminated := doWork(done, nil)

        go func() {         //  3
            //  1秒後に操作をキャンセルする
            time.Sleep(1 * time.Second)
            fmt.Println("Canceling doWork goroutine...")
            close(done)
        }()

        <-terminated        //  4
        fmt.Println("Done.")
    ```
    1. doneチャネルをdoWork関数に渡す。慣例として、このチャネルは第1引数にする。
    2. この行はどこにでも存在するfor-selectパターンを使っている。case文の1つでdoneチャネルからシグナルが送られたかどうかを確認している。もし送られていたら、ゴルーチンからreturnする。
    3. 1秒以上経過したらdoWorkの中で生成されたゴルーチンをキャンセルする他のゴルーチンを生成する。
    4. ここでdoWorkから生成されたゴルーチンがメインゴルーチンとつながる。

    出力結果は次の通り。
    ```
        Canceling doWork goroutine...
        doWork exited.
        Done.
    ```

    nilをstringsチャネルに渡しているにも関わらず、それでもゴルーチンは無事に終了している。
    先の例と違って、この例では2つのゴルーチンをつなげていて、それでもなおデッドロックしていない。
    その理由は、2つのゴルーチンをつながる前に、1秒経過後にdoWorkないのゴルーチンをキャンセルするための3つ目のゴルーチンを生成しているから。
    ゴルーチンリークを無事に取り除けた。

    先の例ではゴルーチンがチャネルでデータを受け取るケースに関してはうまく対応できた。
    しかし逆の状況ではどうだろうか。
    つまり、ゴルーチンがチャネルに対して書き込みを行おうとしてブロックしている状況。
    その問題を実際に示した例がこちら。
    ```
        newRandStream := func() <-chan int {
            randStream := make(chan int)
            go func() {
                defer fmt.Println("newRandStream closure exited.")  //  1
                defer close(randStream)
                for {
                    randStream <- rand.Int()
                }
            }()
            return randStream
        }

        randStream := newRandStream()
        fmt.Println("3 random ints:")
        for i := i; i <= 3; i++ {
            fmt.Printf("%d: %d\n", i, <-randStream)
        }
    ```
    1. ゴルーチンが無事に終了した場合にメッセージを表示する。

    実行結果はこちら
    ```
        3 random ints:
        1: 5577006791947779410
        2: 8674665223082153551
        3: 6129484611666145821
    ```

    出力結果を見てわかるように、deferされたfmt.Printlnの文は決して実行されない。
    3回繰り返しが実行された後に、次の乱数の整数をもう読み込まれていないチャネルに送信しようとしてゴルーチンはブロックしてしまう。生産者側に停止してよいと伝える方法がない。
    解決策は、受信側の例のように、生産者のゴルーチンに終了を伝えるチャネルを提供すること。

    ```
        newRandStream := func(done <-chan interface{}) <-chan int {
            randStream := make(chan int)
            go func() {
                defer fmt.Println("newRandStream closure exited.")
                defer close(randStream)
                for {
                    select {
                    case randStream <- rand.Int():
                    case <-done:
                        return
                    }
                }
            }()

            return randStream
        }

        done := make(chan interface{})
        randStream := newRandStream(done)
        fmt.Println("3 random ints:")
        for i := 1; i <= 3; i++ {
            fmt.Printf("%d: %d\n", i, <-randStream)
        }
        close(done)

        //  処理が実行中であることをシミュレート
        time.Sleep(1 * time.Second)
    ```

    実行すると次のようになる。
    ```
        3 random ints:
        1: 5577006791947779410
        2: 8674665223082153551
        3: 6129484611666145821
        newRandStream closure exited.
    ```

    ゴルーチンがきれいに片づけられた。
    ここまでで、ゴルーチンを確実にリークしないようにする方法を学んだので、次のような規約を明記できるだろう。
    もしあるゴルーチンがゴルーチンの生成の責任を持っているのであれば、そのゴルーチンを停止できるようにする積にもある。

    この規約によってプログラムが構成可能で自由にスケールできるようになる。
    ゴルーチンを停止させるやり方はゴルーチンの種類と目的によって変わるが、いずれもdoneチャネルを渡すという基本に基づく。
    
# Goにおける並行処理の構成要素

- ゴルーチン（goroutine）
    すべてのGoのプログラムには最低1つのゴルーチンがある。
    メインゴルーチン
    これは、プロセスが開始する際に自動的に生成され起動される。
    単純に言えば、ゴルーチンは他のコードに対し並行に実行している関数のこと（注意：必ずしも並列ではない）
    ゴルーチンはgoキーワードを関数呼び出しの前に置くことで簡単に起動できる。
    無名関数でも動作する。（goキーワードを使うには無名関数を即値で呼び出さなければいけない）

    ゴルーチンは（他の言語にも似た並行処理のプリミティブは存在するが）Go特有のもの。
    ゴルーチンはOSスレッドではなく、また必ずしもグリーンスレッド（言語のランタイムにより管理されるスレッド）ではない。
    ゴルーチンはコルーチン（coroutine）として知られる高水準の抽象化。
    コルーチンは単に「プリエンプティブでない」並行処理のサブルーチン（Goでは関数、クロージャー、メソッドに相応）
    つまり割り込みをされることがないということ
    代わりに、コールチンには一時停止や再エントリーを許す複数のポイントがある。

    ```
        プリエンプティブとノンプリエンプティブは、ともにマルチタスクOS上で実行されるプログラムを切り替えるときの方式
        プリエンプティブ
            OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。
        ノンプリエンプティブ
            実行したプロセスの切り替えをプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間で他のタスクを実行する。
            OSがCPUを管理しないので、1つのプログラムを実行中は、他のプログラムの実行は制限される。
    ```

    ゴルーチンが独特なのは、ゴルーチンがGoのランタイムと密結合していること
    ゴルーチンは、一時停止や再エントリーのポイントを定義していない。
    Goのランタイムはゴルーチンの実行時のふるまいを観察し、ゴルーチンがブロックしたら自動的に一時停止し、ブロックが解放されたら再開する。
    これによってある意味ゴルーチンをプリエンプティブにしているが、ゴルーチンがブロックしたときにしか割り込まない。
    このようにランタイムとゴルーチンのロジックには美しい関係性がある。
    以上のことからゴルーチンは特殊なコールチンと考えられる。
    
    コルーチン、また結果としてゴルーチンは、暗黙的には並行処理の構成要素ですが、並行性というのはコールチンの性質ではない。
    並行である場合には、何かが複数のコルーチンが同時管理して、それぞれに実行の機会を与えなければならない。さもなければ、コルーチンが並行になることはない。
    コールチンが暗黙的に並列であるということを示唆するわけではない。
    複数のコルーチンが逐次実行をして（CPUのコア数以上に）並行処理をしているように見せることは確実に可能。
    そしてGoでは常にそれが起こっている。

    Goがゴルーチンをホストする機構は、いわゆるM:Nスケジューラーを呼ばれる実装になっている。
    これはM個のグリーンスレッドをN個のOSスレッドに対応させるもの。
    ゴルーチンはグリーンスレッドにスケジュールされる。
    グリーンスレッドの数よりも多い数のゴルーチンがある場合には、スケジューラーはゴルーチンを利用可能なグリーンスレッドに割り振って、これらのゴルーチンがブロックした場合には他のゴルーチンを実行するようにしている。

    Goはfork-joinモデルを呼ばれる並行処理のモデルに従っている。
    分岐（fork）という用語は、プログラムの任意の場所で、プログラムが子の処理を分岐させて、親と平行に実行させることを指している。
    合流（join）という用語は、分岐した時点から先でこれらの並行処理の分岐が再び合流することを指す。

    ```
        sayHello := func() {
            fmt.Println("hello")
        }

        go sayHello()
    ```

    sayHello関数は自身のゴルーチン上で実行される。かたや、プログラムの続きの部分は引き続き実行される。
    この例には、合流ポイントがない。
    sayHelloを実行しているゴルーチンは単純に将来の不確定なタイミングで終了する。
    プログラムの残りの部分はすでに引き続き実行されている。
    しかしながら、この例には1つ問題がある。
    sayHello関数が実行されたかどうかは不確定。
    ゴルーチンは生成されて、Goのランタイムにスケジュールされるが、もしかするとメインゴルーチンが終了するまでに実行する機会を得られないかもしれない。
    事実、（サンプルを）簡単にするためmain関数の残りの部分を省略したので、この小さなサンプルを実行すると、プログラムがsayHelloの呼び出しをホストしているゴルーチンが起動する前に終了してしまうことがほぼ確実
    ゴルーチンを作った後にtime.Sleepを書くこともできるが、合流ポイントは作成せず、ただ競合状態を作っているだけ。
    プログラムの終了の前にゴルーチンが起動する確率を上げることはできるが、それを保証するものではない。
    合流ポイントはプログラムの正当性を保証し競合状態を取り除くものである。

    合流ポイントを作成するために、メインゴルーチンとsayHelloのゴルーチンを同期しなければならない。
    これはいくつもの方法で実現可能、sync.WaitGroupを使って実装することができる。
    ```
        var wg sync.WaitGroup
        sayHello := func() {
            defer wg.Done()
            fmt.Println("hello")
        }
        wg.Add(1)
        go sayHello()
        wg.Wait()
    ```
    
    この例は決定的にsayHello関数をホストしているゴルーチンが終了するまで、メインゴルーチンをブロックする。
    手早くゴルーチンを生成するためにたくさんの無名関数を使ってきた。
    クロージャは無名関数が作成されたときレキシカルスコープを閉じ込めて、そこに変数を取り込む。
    ゴルーチンの中でクロージャを実行すると、クロージャーはこれらの変数のコピーに対して操作するのか
    それとも元の変数の参照に対してだろうか
    ```
        var wg sync.WaitGroup
        salutation := "hello"
        wg.Add(1)
        go func() {
            defer wg.Done()
            salutation = "welcome"
        } ()
        wg.Wait()
        fmt.Println(salutation)
    ```
    出力は、「welcome」
    ゴルーチンはそれが作られたアドレス空間と同じ空間で実行されることが分かった。
    そしてそれゆえにプログラムが"welcome"を表示している。

    - スコープ
        スコープとは、プログラム中で変数名などのシンボルが参照可能な有効範囲のこと。
        ```
            var hoge = "ほげ";      //  グローバルスコープ（グローバル変数）

            function a() {
                var x = 10;         //  ローカル変数
                console.log(x);
                console.log(hoge);
            }

            function b() {
                var hoge = "hoge";  //  ローカル変数
                console.log(hoge);
            }

            console.log(hoge);      //  ほげ
            console.log(x);         //  error
        ```
    - レキシカルスコープ
        ローカル変数の有効範囲は関数の定義時に決まるものなのか、他の場所で呼び出した時に決まるのか？
        レキシカルスコープは関数を定義した時点でスコープが決まる。
        ```
            var x = 10;
            function A() {
                console.log(x);         //  x = 10
            }

            function B() {
                var x = 1000;           //  ここでも定義されている。
                A();                    //  x = ?
            }

            A()                         //  10
            B()                         //  10
        ```

    - ダイナミックスコープ
        ```
            var x = 10;
            function A() {
                console.log(x);         //  x = 10
            }

            function B() {
                var x = 1000;           //  ここでも定義されている。
                A();                    //  x = ?
            }

            A()                         //  10
            B()                         //  1000（10ではなくなった）
        ```

    - クロージャ
        クロージャは「関数」と「その関数が作られた環境」という2つのものが一体となった特殊なオブジェクト
        この「環境」というのは、クロージャが作られた時点でスコープ内部にあったあらゆる変数や関数・オブジェクトなどによって構成される。
    
        ```
        function fnA() {
            var hoge = "ほげ";
            console.log(hoge);

            function fnB() {
                alert(hoge);
            }

            return fnB;
        }

        var myFunc = fnA();

        myFunc();
        //  myFunc();
        ```

        実行結果
            1. コンソールに"ほげ"という出力がされる
            2. アラートで"ほげ"とメッセージが出現する

        もう一度myFunc();を呼び出してあげると、コンソールの出力はなく、アラートで"ほげ"とでてくるのみ
        ローカル変数hogeは、関数fnA内部のローカル変数であるので、関数fnAの実行中以外では参照することはできないはずです。
        「JavaScriptのローカル変数は、関数が実行されるたびに作成され破棄される」「関数内部のローカル変数は、その関数が実行されている間だけ存在する」

        では、上記の例で関数fnAを実行しているのはどこかというと、変数myFuncが定義されたとき
        つまり、この瞬間でのみ、ローカル変数hogeを参照することができる。
        関数fnAの中身を見ると「return fnB;」とあるので、グローバル変数myFuncに代入されるのは、関数fnBということになる。
        
        「var myFunc = fnA();」の部分を置き換えてみると
        ```
        var myFunc = function fnB() {
            alert(hoge);
        }
        ```

        つまり、「myFunc()」=「alert(hoge);」となる。

        関数fnAが実行されていないのに、関数fnA内部のローカル変数hogeを参照できている
        「クロージャは「関数」と「その関数が作られた環境」という2つのものが一体となった特殊なオブジェクト」

        関数がクロージャになる条件
        「関数は定義時のコンテキストとは異なるコンテキスト上に持ち出されるとクロージャになる」

        関数fnAのような親関数の実行によって、ローカル関数が外部へと持ち出されるときにクロージャが生成されることが分かった。
        このような、クロージャを生成できる親関数のことを「エンクロージャー」と呼ぶらしい

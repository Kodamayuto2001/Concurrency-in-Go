# 並行処理入門

並行処理とは何を指すのか？定義について明確にする。

### 一般的
- 1つ以上の処理が同時に発生する処理のことを指す

### Concurrency-in-Go的
- 本書で紹介する。（具体的には、Goは並行性をどのようにモデル化するか、このモデルで生じる問題は何か、それらの問題を解決するためにどのようにプリミティブを組み合わせていくかについてのみ）

並行性が重要になった理由、並行性が難しく入念な研究が必要となる理由、これらの課題があるにもかかわらずGoではその並行性のプリミティブを使ってなぜプログラムをきれいにそして早く書けるのか
上記を紐解くためには、「並行処理の歴史」を知る必要がある。

## 並列処理の歴史
- ムーアの法則
- アダムールの法則
- Spigotアルゴリズム
- Webスケール

## なぜ並行処理が難しいのか
- 競合状態
    ```
        var data int
        go func() {
            data++
        }()
        if data == 0 {
            fmt.Printf("the value is %v.\n", data)
        }
    ```
    - なにも表示されない。この場合3行目は5行目の前に実行される。
    - the value is 0が表示される。この場合、5-6行目は3行目の前に実行される。
    - the value is 1が表示される。この場合、5行目は、3行目の前に実行されるが、3行目は、6行目の前に実行される。

    ```
        var data int
        go func() {data++}()
        time.Sleep(1*time.Second)
        if data == 0 {
            fmt.Printf("the value is %v.\n", data)
        }
    ```
    競合が起こりにくくなっただけで、先の3つは起こりえる。
    スリープを加えたことによって、アルゴリズムの中に非効率なものを入れてしまった。

- アトミック性
    - 「コンテキスト」が重要
        例えば、あなたの処理のコンテキストの中ではアトミックな操作も、オペレーティングシステムというコンテキストではアトミックでないかもしれない。
        ある操作のアトミック性というのは、現在注目しているスコープによって変わりえる。
    
    - 「分割不能」と「中断不可」
        ```
            i++
        ```
        - iの値を取得する。
        - iの値を1増やす。
        - iの値を保存する。
        ひとつひとつの操作はそれぞれアトミックだが、これら3つを組み合わせるとコンテキストによってはアトミックでなくなる。
        アトミックな操作を組み合わせても必ずしも大きなアトミックな操作を作れるわけではない
        操作がアトミックになるかどうかは、アトミックにしたいコンテキストに依存する。
        コンテキストに1つも並行処理がないプログラムであれば、このコードはそのコンテキスト内ではアトミック
        もしiを他のゴルーチンに公開しないようなコンテキストのゴルーチンの場合、このコードはアトミック

    - アトミック性の重要性
        あるものがアトミックであれば、それを複数の平行なコンテキストで安全に扱えることが暗黙的に保障されているから
        この性質によって論理的に正しいプログラムを構成できるようになる。
        また、この性質は並行プログラムを最適化することにも使える。

- メモリアクセス同期
    データ競合があった場合で、2つの並行処理がメモリの同じ領域にアクセスしようとしていて、ともにアトミックでないアクセスだったとする。
    ```
        var data int
        go func() { data++ }()
        if data == 0 {
            fmt.Println("the value is 0.")
        } else {
            fmt.Printf("the value is %v.\n", data)
        }
    ```
    else句を追加して、dataの値に関係なく出力するようにした。これはデータ競合で、プログラムの出力は完全に非決定的
    実際、プログラム内で共有リソースに対する排他的なアクセスが必要な場所には名前がある。
    それは、クリティカルセクションと呼ばれている。上記の例の場合、次の3つがクリティカルセクション    
    - 
        - ゴルーチン。data変数をインクリメントしている。
        - if文。dataの値が0かを確認している。
        - fmt.Printf文。dataの値を取ってきて出力している。    
        
    - クリティカルセクションを守る方法
    

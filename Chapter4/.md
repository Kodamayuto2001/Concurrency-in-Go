# Goでの並行処理パターン

- 拘束
    並行なコードを扱うときに、安全な操作をするためにはいくつかの異なる方法が考えられる。
    これまで見てきたものは以下の通り。
    
    - メモリを共有するための同期のプリミティブ（例：sync.Mutex）
    - 通信による同期（例：チャネル）

    しかしながら、複数の並行プロセス内で暗黙的に安全な方法が他にもいくつかある。

    - イミュータブルなデータ
    - 拘束によって保護されたデータ

    ある意味で、イミュータブルなデータは暗黙的に「並行処理において安全」であり理想的
    各並行プロセスは同じデータに対して操作できるが、変更できない。
    新しいデータを作りたければ、そのデータをコピーしてから必要な変更を行う。
    これによって開発者がデータの中身を認識する負荷を軽減するだけでなく、クリティカルセクションを小さく（あるいはまったく無く）して、より速いプログラムにもなりえる。
    Goではメモリ内の値へのポインターの代わりに値のコピーを使るようなプログラムを書くことで実現できる。
    言語によっては、明示的にイミュータブルな値をもったポインターを扱うことができるが、Goではできない。

    拘束によっても開発者がデータの中身を認識する負荷を下げ、クリティカルセクションを小さくできる。
    並行処理で扱う値を拘束する技術は単純に値のコピーを渡すよりやや複雑になる。

    拘束は、情報をたった1つの並行プロセス空のみ得られることを確実にしてくれる単純だが強力な考え方。
    これが確実に行われたときには、並行プログラムは暗黙的に安全で、また同期が全く必要なくなる。
    拘束は2種類存在している。
    アドホックとレキシカルの2つ。

    アドホック拘束とは、拘束を規約（例えば言語コミュニティ、職場のチーム、あるいは触っているコードベースなどによって指定されている規則）によって達成した場合を指す。
    どのような規模のコミュニティにおいても、誰かがコードをコミットするたびに静的解析を実行してくれるようなツールがない限り、規則を守り続けるのは難しい。
    アドホック拘束の例を以下に示す。

    ```
        data := make([]int, 4)

        loopData := func(handleData chan<- int) {
            defer close(handleData)
            for i := range data {
                handleData <- data[i]
            }
        }

        handleData := make(chan int)
        go loopData(handleData)

        for num := range handleData {
            fmt.Println(num)
        }
    ```

    整数のスライスであるdataがloopData関数でもhandleDataチャネルに対する繰り返しでも利用できることが分かる。
    しかしながら、規約によってloopData関数のみからアクセスしている。
    しかし、コードが多くの人に手を入れられて、締め切りが迫ってくるにつれて、間違ったコードが混入し、拘束が破られて、問題が起きる。
    静的解析ツールはこういった類の問題を捕まえてくれるかもしれない。
    Goのコードベースに対する静的解析の導入は「多くの開発チームがそれを導入できる成熟度に到達できていない」ことを示す。
    レキシカル拘束を好む理由。
    これはコンパイラを駆使して拘束を強制するというもの。

    レキシカル拘束はレキシカルスコープを使って適切なデータと並行処理のプリミティブだけを複数の並行プロセスが使えるように公開することを示している。
    これによって誤った処理を書いてしまうことを不可能にしている。
    チャネルを必要とする並行プロセスにそのチャネルへの読み書きのうち必要な権限だけ公開する。

    ```
        chanOwner := func() <-chan int {
            results := make(chan int, 5)        //  1
            go func() {
                defer close(results)
                for i := 0; i <= 5; i++ {
                    results <- i
                }
            }()
            return results
        }

        consumer := func(results <-chan int) {  //  3
            for result := range results {
                fmt.Printf("Received: %d\n", result)
            }
            fmt.Println("Done receiving!")
        }

        results := chanOwner()                  //  2
        cosumer(results)
    ```

    1. チャネルをchanOwner関数のレキシカルスコープ内で初期化している。これによってresultsチャネルへの書き込みができるスコープを制限している。言い換えれば、このチャネルへの書き込み権限を拘束して、他のゴルーチンの書き込みを防いでいる。
    2. チャネルへの読み込み権限を受け取って、消費者に渡す。消費者は読み込み以外は何もしない。再度になるが、これによりメインゴルーチンにはこのチャネルへの読み込みだけが見えるように拘束する。
    3. intのチャネルの読み込み専用のコピーを受け取る。読み込み権限のみが必要であることを宣言することで、consumer関数内でのこのチャネルに対する操作を読み込み専用に拘束する。

    このように設定することで、この小さな例の中にあるresultチャネルは直接利用できなくなる。
    これは拘束の良い導入ではあるが、チャネルは並行安全なのでおもしろい例ではない。
    並行安全ではないデータ構造を使った高速の例。ここではbytes.Bufferを使う。

    ```
        printData := func(wg *sync.WaitGroup, data []byte) {
            defer wg.Done()

            var buff bytes.Buffer
            for _, b := range data {
                fmt.Fprintf(&buff, "%c", b)
            }
            fmt.Println(buff.String())
        }

        var wg sync.WaitGroup
        wg.Add(2)
        data := []byte("golang")
        go printData(&wg, data[:3])     //  1
        go printData(&wg, data[3:])     //  2
    ```

    1. dataの中の先頭の3バイトを含んだスライスを渡す。
    2. dataの中の後半の3バイトを含んだスライスを渡す。
    
    この例でprintDataはdataスライスの宣言の後にないので直接アクセスできず、引数としてbyteのスライスを渡してもらう必要がある。
    printDataを呼び出すゴルーチンでそれぞれ別の部分集合を渡しているので、起動したゴルーチンがそれぞれdataの一部しかアクセスできないように拘束している。
    レキシカルスコープによって、間違ったアクセスを不可能にした。
    またこうすることでメモリアクセスの動機や通信によるデータの共有を行う必要がなくなる。

    同期を利用できるのに、なぜ高速を使おうとするのか？
    パフォーマンス向上と、開発者に対する可読性の向上が理由。
    同期はコストが高くなり、使用を避けることができればクリティカルセクションを持たずに済む。
    またそれゆえに、同期のコストを書ける必要がなくなる。
    また同期を行うことで発生しうる問題すべてを回避できる。
    つまり開発者は単純にこういった類の問題を全く気にする必要がなくなる。
    さらにレキシカル拘束を利用する並行処理のコードは、そうでないコードに比較して一般的には理解しやすいものになるという利点がある。
    その理由は、レキシカルスコープのコンテキストの中では同期なコードを書けるから。

    拘束をきちんと作るのは難しいこともある。
    そのさいは、Goの並行処理のプリミティブを利用しなければならなくなる。


- for-selectループ
    ```
        for {           //  無限ループまたは何かのイテレーションを回す
            select {
                //  チャネルに対して何かを行う
            }
        }
    ```

    //  このパターンが出現するシナリオはいくつかある。

    - チャネルから繰り返しの変数を送出する。
        しばしば繰り返しが可能なものをチャネル上の変数に変換したいことがある。
        これは全く派手ではない。
        次のような見た目となる。
        ```
            for _, s := range []string{"a", "b", "c"} {
                select {
                case <-done:
                    return
                case stringStream <- s:
                }
            }
        ```

    - 停止シグナルを待つ無限ループ
        外部から停止の命令が来るまで無限に繰り返すゴルーチンを作るのはよくあること。
        パターンにはいくつかの変形がある。
        1つ目の形式はselect文を極力短くするもの。
        ```
            for {
                select {
                case <-done:
                    return
                default:
                }

                //  割り込みできない処理をする
            }
        ```

        doneチャネルが閉じられていなければ、select文を抜けてforループの本体の残りの処理を続ける。
        2つ目の形式ではselect文のdefault節に処理を埋め込む
        ```
            for {
                select {
                case <-done:
                    return
                default:
                    //  割り込みできない処理をする
                }
            }
        ```
        select文に入ったときに、doneチャネルが閉じられていなければ、代わりにdefault節を実行する。
        このパターンに関してはこれ以上のものはない。
        しかし、このパターンはどこでも見かけるので、ここで触れておく価値はあるだろう。

    